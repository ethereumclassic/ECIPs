---
ecip: 1122
title: ML-DSA (FIPS 204) Signature Verification Precompile(s)
lang: en
translator:
author: Daniel Tocila
discussions-to: https://github.com/ethereumclassic/ECIPs/discussions
status: WIP
type: Standards Track
category: Core
created: 2026-01-25
requires: 1103
replaces:
superseded-by:
resolution:
---

## Abstract

This ECIP introduces one or more native EVM precompiles for verifying post-quantum digital signatures
using **ML-DSA** as standardized in **NIST FIPS 204** (formerly known as CRYSTALS-Dilithium).

The purpose of this change is to provide an efficient, consensus-safe primitive that enables
quantum-resistant account control via smart contracts (e.g., contract wallets / account abstraction patterns),
and to serve as a building block for future protocol-native post-quantum transaction signature formats.

This ECIP does **not** change existing ECDSA-based externally owned accounts (EOAs) or legacy transaction
signature validation.

## Motivation

Ethereum Classic transaction signatures are based on ECDSA over an elliptic curve. ECDSA signatures on ETC
include recovery identifiers such that a public key can be recovered from signed transactions, meaning that
for any account that has broadcast a transaction, the public key becomes publicly known.

Large-scale quantum computers running Shor-style discrete-log algorithms would be expected to break the
security assumptions of ECC, enabling theft from accounts whose public keys are known.

The ETC ecosystem benefits from a pragmatic, incremental path:
1. Enable PQ signature verification efficiently at the EVM level (this ECIP).
2. Standardize PQ-secure contract-wallet account formats and migration tooling (ECBP or companion spec).
3. Optionally add a protocol-native PQ transaction type in a later ECIP, once the ecosystem has confidence.

Adding a precompile is a well-understood EVM evolution mechanism and aligns with Ethereum Classic’s ongoing
goal of EVM compatibility and “adopt proven EIPs” where appropriate.

## Specification

### Overview

At the activation block, clients MUST add a new precompiled contract (or set of precompiled contracts)
that verifies ML-DSA signatures as defined by NIST FIPS 204.

This ECIP proposes **one required precompile** for ML-DSA-65 (NIST security category 3), and **optionally**
two additional precompiles for ML-DSA-44 and ML-DSA-87.

Key and signature sizes from FIPS 204 (Table 2):
- ML-DSA-44: pk=1312 bytes, sig=2420 bytes
- ML-DSA-65: pk=1952 bytes, sig=3309 bytes
- ML-DSA-87: pk=2592 bytes, sig=4627 bytes

### Precompile Address Range

To minimize the risk of changing behavior of existing deployed contracts, the precompile(s) SHOULD be placed
in a range reserved for native precompiles and avoided by application contracts.

This ECIP proposes using the `0x0100..0x01FF` range.

Proposed addresses (subject to discussion):
- `0x0000000000000000000000000000000000000101` : ML-DSA-65 verify (REQUIRED)
- `0x0000000000000000000000000000000000000102` : ML-DSA-44 verify (OPTIONAL)
- `0x0000000000000000000000000000000000000103` : ML-DSA-87 verify (OPTIONAL)

If the community prefers an ETC-specific reserved range, these addresses may be revised before Final status.

### Call Semantics (Inputs/Outputs)

All precompiles are **pure** and MUST be callable via `STATICCALL`.

#### Input Encoding (common)

Input is a byte array:

`input = pk || sig || msg`

Where:
- `pk` is the ML-DSA public key bytes (fixed length per parameter set)
- `sig` is the ML-DSA signature bytes (fixed length per parameter set)
- `msg` is the message bytes (variable length, may be zero length)

The precompile MUST reject (return invalid) if `input.length < (pkLen + sigLen)`.

Parsing:
- `pk = input[0 : pkLen]`
- `sig = input[pkLen : pkLen + sigLen]`
- `msg = input[pkLen + sigLen : ]`

#### Output Encoding

Return exactly 32 bytes:
- `0x000...0001` (32-byte big-endian integer 1) if signature is valid
- `0x000...0000` otherwise

The precompile MUST NOT revert for invalid signatures. It MUST return 0 on:
- invalid signature
- wrong input lengths
- malformed encodings per FIPS 204 requirements
- any internal verification failure

### Gas Cost

This ECIP introduces a new gas schedule constant per supported parameter set.

Because ML-DSA verification has a bounded runtime for a fixed parameter set, gas cost SHOULD be mostly fixed,
with a small per-word component for message hashing overhead.

Proposed gas schedule (INITIAL VALUES FOR DISCUSSION; MUST be benchmarked in at least two client implementations):
- ML-DSA-65 verify:
  - `G_MLDSA65_BASE = 250,000`
  - `G_MLDSA65_PER_WORD = 12`  (word = 32 bytes, applied to `ceil(msgLen/32)`)
  - Total: `G = G_MLDSA65_BASE + G_MLDSA65_PER_WORD * ceil(msgLen/32)`

Optional sets:
- ML-DSA-44:
  - `G_MLDSA44_BASE = 200,000`
  - `G_MLDSA44_PER_WORD = 12`
- ML-DSA-87:
  - `G_MLDSA87_BASE = 350,000`
  - `G_MLDSA87_PER_WORD = 12`

Clients MUST charge at least the computed gas prior to executing verification, and follow standard EVM
memory expansion rules as applicable.

### Consensus / Fork Activation

This ECIP requires a hard fork because it changes EVM behavior at specific addresses.

Activation block numbers:
- Mordor Testnet: TBD
- Mainnet: TBD

## Rationale

### Why ML-DSA first?

ML-DSA is standardized by NIST (FIPS 204) and offers a favorable performance profile compared to hash-based
signatures, while still being designed for security against quantum adversaries.

### Why a precompile (vs pure Solidity)?

On-chain PQ signature verification in Solidity would be prohibitively expensive. A precompile provides:
- predictable gas costs
- consistent behavior across clients
- practical viability for contract wallets and migration tools

### Why ML-DSA-65 (category 3)?

ML-DSA-65 provides a high security category while keeping signature sizes lower than ML-DSA-87.
The community may choose a different required parameter set based on risk tolerance and cost.

### Why this does not immediately replace ECDSA transaction signatures

Protocol-native transaction signature changes require:
- new transaction format(s)
- mempool validation updates
- wallet/tooling coordination
- large-scale migration and replay-safety considerations

This ECIP focuses on a minimal, additive primitive that enables immediate experimentation and adoption
via contract wallets, without destabilizing existing transaction processing.

## Backwards Compatibility

This ECIP is not backward compatible at the EVM level:
- Calls to the chosen precompile address(es) that previously executed as normal calls (typically returning
  empty data) will change behavior after activation.

Mitigation:
- Choose an address range that is treated as reserved for precompiles.
- Provide a public announcement and ecosystem guidance well before mainnet activation.

No changes are made to:
- transaction format(s)
- ECDSA signature validation for EOAs
- address derivation rules

## Test Cases

Client implementations MUST include:
1. Verification Known Answer Tests (KATs) derived from NIST FIPS 204 test vectors for ML-DSA-65
2. Negative tests:
   - wrong signature length
   - wrong public key length
   - modified message
   - modified signature
   - empty input
3. Cross-client consensus tests on Mordor:
   - identical outputs and gas usage for a suite of calls at various message lengths

A reference test corpus SHOULD be published alongside the ECIP implementation.

## Security Considerations

- This ECIP does not by itself prevent quantum theft from existing ECDSA-controlled EOAs.
  It provides tooling primitives to build migration paths.
- Implementations must be constant-time where required and carefully audited for side channels.
- Gas schedule MUST be calibrated to prevent DoS vectors where verification is underpriced.
- Input validation MUST be strict (length checks, encoding checks) to prevent differential behavior across clients.

## Implementation

Reference implementations are expected in:
- Core-Geth (Go)
- Other ETC-capable clients willing to adopt

Suggested implementation strategy:
- Use a well-maintained ML-DSA implementation with clear licensing and test vectors.
  (Example: Cloudflare CIRCL includes ML-DSA implementations under `sign/mldsa`.)

Implementation notes:
- Add to the precompile registry with the selected address(es).
- Implement strict input parsing and fixed-size enforcement per parameter set.
- Return 32-byte 0/1 outputs; never revert on invalid signatures.

## Future Work (Non-Normative)

Follow-on items (potential additional ECIPs / ECBPs):
1. Standard contract-wallet interface for PQ accounts on ETC.
2. Migration tooling and “safe address” guidance for users/exchanges.
3. Protocol-native PQ transaction type (typed transaction envelope) that allows direct PQ-signed transactions.

## References

- NIST FIPS 204: Module-Lattice-Based Digital Signature Standard (ML-DSA)
- ETC ECIP Process (ECIP-1000)
- ECIP-1103 (Magneto): EIP-2718 typed transaction envelope adoption
- ETC digital signatures overview (recovery identifiers / pubkey recovery)
- Proos & Zalka: Shor’s discrete logarithm algorithm for elliptic curves

## Copyright/Licensing

Copyright and related rights waived via CC0.
