---
lang: en
ecip: 1120
title: Basefee Market with Miner Rewards
subtitle: A minimally complicated implementation of EIP-1559 for Ethereum Classic
author: Istora Mandiri (@IstoraMandiri), Diego López León (@diega)
status: WIP
type: Standards Track
category: Core
created: 2025-12-04
discussions-to: https://github.com/orgs/ethereumclassic/discussions/541
license: CC0-1.0
---

## Abstract

This ECIP introduces a minimally complicated implementation of [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559) for Ethereum Classic.

EIP-1559 was introduced on Ethereum Mainnet in August 2021 during its [London Hard Fork](https://eips.ethereum.org/EIPS/eip-1559). Thanks in part to improved user experience and more efficient transaction pricing, EIP-1559 has achieved widespread adoption across many EVM chains. In turn, EVM-compatible wallets and smart contract systems are increasingly designed with the assumption that EIP-1559 is a baseline standard.

For users of Ethereum Classic to enjoy the benefits of 1559, and for the ETC protocol to maintain future-proof compatibility with the wider EVM ecosystem, the adoption of a 1559-compatible format is increasingly desirable. To this end, ECIP-1120 gives users the option to price transactions using an algorithmic Basefee Market, via the opt-in "Type 2" transaction.

In Ethereum's implementation of EIP-1559, the Basefee is burned, but this is [not practical](#why-not-burn-or-redirect) for Ethereum Classic. Instead, ECIP-1120 proposes that the Basefee is distributed in full to miners to maximize long-term security budget, which will become increasingly important during the tail-end of the emission curve in the coming decades.

This ECIP presents key recommendations, with in-depth research findings linked in the [Research Plan](#research-plan) section.

## Motivation

ECIP-1120 exists partly in response to the [ECIP-111[1-5]](https://ecips.ethereumclassic.org/ECIPs/ecip-1111) set of proposals, which recommend a redirection of the Basefees to a treasury governed by on-chain smart contracts. In contrast, the goal of this ECIP is to identify the least complex and most secure 1559-like implementation within real-world technical design constraints, rather than pursuing second-order ambitions that require additional complexity and thus present additional security concerns.

ECIP-1120 presents a math-only, protocol-neutral, protocol-native solution that distributes all fees to miners without any smart contracts or a governance system. It is fully self-contained, describing everything needed for an implementation without creating new domains of inquiry.

## Specification

ECIP-1120 consists of two key mechanisms - a **Basefee Market** and a **Basefee Distribution** - that together define a 1559-like protocol upgrade for Ethereum Classic.

### Basefee Market

The Basefee Market component is essentially a straightforward replication of relevant aspects of EIP-1559, with a Block Elasticity Multiplier optimized for ETC.

#### Type 2 Transactions

Type 2 transactions, using the envelope format defined in [EIP-2718](https://eips.ethereum.org/EIPS/eip-2718), allow users to specify a maximum fee and a priority fee (tip), with the protocol algorithmically determining the Basefee based on network demand. Block elasticity allows blocks to temporarily exceed the target gas limit during demand spikes, with the Basefee adjusting to bring utilization back to target. These mechanisms are detailed in the sections below.

As per [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559), each Type 2 transaction must satisfy:

```typescript
// Pseudocode: Type 2 transaction validation and effective gas price calculation.
// Ensures the transaction can pay the Basefee and calculates the miner's priority fee.

// User must be willing to pay at least the current Basefee
assert(transaction.maxFeePerGas >= block.baseFeePerGas);
// Priority fee cannot exceed the max fee (would be nonsensical)
assert(transaction.maxFeePerGas >= transaction.maxPriorityFeePerGas);
// User must have enough balance to cover worst-case gas cost
assert(signer.balance >= transaction.gasLimit * transaction.maxFeePerGas);

// Priority fee is capped by either the user's specified max priority fee,
// or the remaining fee budget after paying Basefee (whichever is lower)
const priorityFee = min(
  transaction.maxPriorityFeePerGas,
  transaction.maxFeePerGas - block.baseFeePerGas
);
// Effective price paid per gas unit: Basefee goes to distribution, priority fee to miner
const effectiveGasPrice = priorityFee + block.baseFeePerGas;
```

#### BASEFEE Opcode

The `0x48` opcode will be introduced and will return the current block's Basefee, as specified in [EIP-3198](https://eips.ethereum.org/EIPS/eip-3198).

#### Basefee Calculation

The Basefee adjusts dynamically based on network demand. When blocks are fuller than the target, the Basefee increases. When blocks are emptier than the target, it decreases. This creates a self-correcting mechanism that targets 50% block utilization over time.

As per [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559):

```typescript
// Pseudocode: Basefee calculation for the next block.
// Adjusts Basefee up or down based on how full the parent block was relative to target.

// Calculate the target gas usage (equilibrium point where Basefee stays stable)
const parentGasTarget = parent.gasLimit / ELASTICITY_MULTIPLIER;

let expectedBaseFee: bigint;
if (parent.gasUsed === parentGasTarget) {
  // Block was exactly at target: Basefee remains unchanged
  expectedBaseFee = parent.baseFeePerGas;
} else if (parent.gasUsed > parentGasTarget) {
  // Block was above target: increase Basefee to reduce demand
  const gasUsedDelta = parent.gasUsed - parentGasTarget;
  // Calculate proportional increase, minimum of 1 wei to ensure upward pressure
  const BaseFeeDelta = max(
    (parent.baseFeePerGas * gasUsedDelta) /
      parentGasTarget /
      BASE_FEE_MAX_CHANGE_DENOMINATOR,
    1n
  );
  // New Basefee = previous Basefee + delta (fee increases)
  expectedBaseFee = parent.baseFeePerGas + BaseFeeDelta;
} else {
  // Block was below target: decrease Basefee to encourage more transactions
  const gasUsedDelta = parentGasTarget - parent.gasUsed;
  // Calculate proportional decrease (can reach zero, no minimum)
  const BaseFeeDelta =
    (parent.baseFeePerGas * gasUsedDelta) /
    parentGasTarget /
    BASE_FEE_MAX_CHANGE_DENOMINATOR;
  // New Basefee = previous Basefee - delta (fee decreases)
  expectedBaseFee = parent.baseFeePerGas - BaseFeeDelta;
}
```

With a `BASE_FEE_MAX_CHANGE_DENOMINATOR` of `8`, the Basefee can change by a maximum of `±12.5%` per block.

### Basefee Market Parameters

Parameter selection requires client benchmarking (Core-Geth, Besu) and historical network analysis. Final values are subject to [ongoing research](#research-plan).

- **Base Gas Target** - 8,000,000 gas per block (based on current ETC gas limit)
- **Initial Basefee** - 1 gwei at fork block, adjusts to market conditions within minutes
- **Basefee Max Change Denominator** - TBD (assumed 8, allowing ±12.5% max change per block as per EIP-1559)
- **Max Gas Limit** - TBD, dependent on [elasticity research](#research-plan)
- **Elasticity Multiplier** - TBD, derived from Max Gas Limit / Base Gas Target

#### Block Elasticity

In EIP-1559, the **gas target** is the equilibrium level where Basefee remains stable, while the **gas limit** is the maximum capacity per block. These are related by the formula `gas_limit = gas_target × elasticity_multiplier`. Blocks can vary between empty and fully utilized, with the Basefee algorithm incentivizing average utilization toward the target.

On Ethereum, EIP-1559 sets a block elasticity multiplier of 2x. With [Ethereum's current block gas limit of 60m](https://www.theblock.co/post/380687/ethereum-block-gas-limit-fusaka), this means a gas target of 30m. Since individual transactions can consume up to the full block gas limit, this enables large contract deployments or executions such as L2 state validation that consume significant gas.

This ECIP presents an opportunity to bring Ethereum Classic closer to feature parity with Ethereum. Ethereum Classic's current limit of 8 million is controlled by miners, but client defaults recommend this conservative value to minimize state bloat.

By increasing the block elasticity multiplier from 2x, a higher value such as 4x, 16x, or even 32x could be considered, enabling maximum transaction sizes equal to or greater than Ethereum, supporting large contract deployments and L2 settlement operations. Crucially, this can be achieved while still maintaining a much more conservative average block size and thus minimal state bloat over time, more in line with the Ethereum Classic ethos.

[Research is ongoing](#research-plan) to determine a safe maximum elasticity value. The goal is to identify a reasonable multiplier given real-world hardware capabilities and network conditions on the Ethereum Classic network, including how the Basefee adjustment rate interacts with higher elasticity values.

### Basefee Distribution

In Ethereum's implementation of EIP-1559, the Basefee is burned. Instead, ECIP-1120 proposes that Basefees are distributed to miners using a backward-looking mechanism, a form of "ℓ-smoothing" as described in [Roughgarden's analysis](https://timroughgarden.org/papers/eip1559.pdf) (Section 8.3.1).

In ECIP-1120, total miner rewards will consist of:

- **Block Subsidy** - based on the [ECIP-1017](https://ecips.ethereumclassic.org/ECIPs/ecip-1017) emission curve, and
- **Priority Fees** - optional tips, as a fallback pricing mechanism when blocks are full, and
- **Distributed Fees** - a portion of the Basefees collected from each of the previous `N` ancestor blocks, calculated as follows:

```typescript
// Pseudocode: Backward-looking fee distribution calculation.
// Sums a portion of Basefees from each of the previous N ancestor blocks.

function calculateDistributedFees(
  blockchain: Blockchain,
  parentHash: Hash
): bigint {
  let totalFees = 0n;
  // Start traversal from the parent block
  let ancestorHash = parentHash;

  // Iterate through the previous N blocks (the "lookback window")
  for (let i = 0; i < N; i++) {
    const ancestor = blockchain.getBlockHeader(ancestorHash);
    // Each ancestor contributes a portion of its collected Basefee.
    // Total Basefee collected = BaseFee * gasUsed (fee per gas × gas consumed).
    // Divide by block count to spread each block's fees across N future blocks.
    const ancestorFee = (ancestor.baseFee * ancestor.gasUsed) / N;

    totalFees += ancestorFee;

    // Move to the next older block in the chain
    ancestorHash = ancestor.parentHash;
  }

  // Return the sum of fee portions from all ancestors in the lookback window
  return totalFees;
}
```

Specific parameters, including `N` and the shape of the distribution curve (linear vs decay), are to be determined by [further research](#research-plan).

## Rationale

### Why Not Burn or Redirect?

Under [ECIP-1017](https://ecips.ethereumclassic.org/ECIPs/ecip-1017), ETC has a fixed emission schedule with block subsidies decreasing 20% every 5 million blocks. Burning fees would interfere with this monetary policy, and as subsidies diminish during tail-end emissions, transaction fees become increasingly important for miner revenue and chain security.

Redirecting fees to a Treasury or DAO, in addition to reducing the security budget, introduces myriad governance complexities and smart contract dependencies.

By directing all transaction fees to miners, as they are today:

- Complexity and attack surface are kept to a minimum
- Protocol neutrality is maintained
- Governance issues are sidestepped
- The social contract between miners and developers remains unchanged

By incentivizing mining as much as possible, ECIP-1120 prioritizes the security and long-term sustainability of the chain.

### Why Smoothing?

An immediate payment to the block's miner is vulnerable to manipulation via spam transactions and off-chain fee agreements. This ECIP instead distributes Basefees to miners using an algorithmic backward-looking smoothing mechanism.

Smoothing fees across blocks also helps avoid a "death spiral" when the block subsidy approaches zero. Without smoothing, empty blocks offer no reward, removing incentive to mine them. This causes irregular block times, discouraging transactions, further reducing miner revenue and resulting in a destructive feedback loop.

### Why Protocol-Native?

This ECIP keeps fee distribution logic at the protocol layer rather than delegating to smart contracts. Keeping this logic outside the EVM dramatically reduces complexity, making the mechanism simpler to implement, test, and audit across client implementations.

Crossing the protocol/application boundary introduces additional concerns:

- **Attack surface** - Smart contracts introduce reentrancy, overflow, and other vulnerability classes that do not exist at the protocol layer.
- **Governance capture** - If a governance system is involved, it becomes susceptible to capture, bribery, or manipulation by well-resourced actors.
- **Code is Law** - Embedding fee logic in contract state creates immutability expectations that may conflict with future necessary adjustments, potentially forcing contentious interventions that undermine ETC's principles.
- **Future adaptability** - Protocol-layer logic can be optimized or modified in future hard forks, whereas contract-based solutions are constrained by EVM limitations and may miss opportunities for deeper integration or performance improvements.
- **Resource overhead** - Smart contract execution consumes gas and adds computational load to every block, whereas protocol-native logic executes outside the EVM with no gas cost.

A protocol-native approach maintains a clean separation of concerns. The protocol handles consensus-critical fee mechanics, while the application layer remains focused on user-facing functionality.

### Why Stateless?

The backward-looking approach is deliberately stateless. The distributed fee amount is derived entirely from existing block header data, with no additional state variables required. This dramatically simplifies implementation, testing, and auditing.

A forward-looking accumulator would require stateful tracking that complicates re-org handling. When a reorg occurs, stateful data (such as an accumulator or reservoir balance) would require rolling back previous operations and tracking the history of changes to correctly restore state on the canonical chain. This adds implementation complexity, increases the attack surface, and imposes additional memory and disk costs during fork transitions.

Stateless calculation allows nodes to simply recompute the fee distribution from the new canonical chain's block headers, requiring no rollback logic, no state corruption risk, and no additional storage beyond what is already required for block headers.

## Backwards Compatibility

### Legacy Transactions

Type 0 (legacy) and Type 1 ([EIP-2930](https://eips.ethereum.org/EIPS/eip-2930) access list) transactions remain fully supported. These transactions are treated as having `maxFeePerGas = maxPriorityFeePerGas = gasPrice`, ensuring backwards compatibility with existing transaction workflows.

### Block Header Changes

This ECIP adds a `BaseFeePerGas` field to the block header, as specified in [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559). This field is RLP-encoded as a 256-bit integer appended to the existing header structure. The block hash calculation includes this new field, making post-fork blocks incompatible with pre-fork clients.

### Wallet and Tooling Compatibility

Wallets and tooling that support EIP-1559 on other EVM chains will work with minimal changes. Existing Ethereum Classic wallets will be encouraged to upgrade to Type 2 transactions to improve user experience. Gas estimation APIs should account for the Basefee, and transaction signing should support Type 2 envelope format per [EIP-2718](https://eips.ethereum.org/EIPS/eip-2718).

### Client Requirements

A hard fork is required. All ETC clients (Core-Geth, Besu) must upgrade before the activation block. Non-upgraded nodes will reject post-fork blocks and fork onto an incompatible chain.

## Security Considerations

### 51% Attack Resistance

Since all fees are returned to miners, total miner compensation remains essentially unchanged compared to the current fee market, with no reduction in security budget other than a reduction in mispriced transactions. This contrasts with fee-redirection mechanisms that permanently remove value from the security budget. As block subsidies decline under [ECIP-1017](https://ecips.ethereumclassic.org/ECIPs/ecip-1017), maintaining full fee distribution to miners becomes increasingly important for sustaining the cost of 51% attacks.

### Manipulation Resistance

The distribution mechanism is designed to satisfy key incentive compatibility properties, including **MMIC** (miners have no short-term incentive to deviate from honest behavior), **UIC** (users have a dominant strategy of bidding their true value), and **OCA-proofness** (resistance to off-chain fee agreements between miners and users). Detailed analysis is covered in the [Manipulation Resistance Analysis](#manipulation-resistance-analysis) research.

### Resource Exhaustion Attacks

Increased block elasticity expands the potential for denial-of-service attacks where adversaries submit computationally expensive transactions to slow block processing or network propagation. To mitigate this, [client benchmarking](#client-benchmarking) will establish safe parameter values for specific hardware configurations. Final elasticity and gas limit values will be chosen to ensure that even worst-case blocks (maximum gas, adversarial transaction patterns) can be processed within acceptable time bounds on recommended node hardware.

### MEV-related Attacks

[Miner Extractable Value (MEV)](https://www.mev.wiki/) refers to profit that miners can extract by reordering, inserting, or censoring transactions within blocks. High-value blocks create incentives for chain reorganizations to capture outsized rewards.

Fee smoothing via backward-looking distribution reduces block reward variance, decreasing the incentive to re-org for high-fee blocks. Since fees are distributed across multiple blocks, no single block presents an outsized MEV opportunity. Detailed analysis of MEV-related attack vectors is covered in the [Manipulation Resistance Analysis](#manipulation-resistance-analysis) research.

## Research Plan

Before moving from WIP to Draft, research will be completed in roughly the folloiwng order.

All research findings will be published at https://ecip1120.dev.

### [Economic Security Analysis](https://ecip1120.dev/economic-modeling)

Model long-term miner revenue under various fee scenarios as block subsidies decline. Verify that the distribution mechanism maintains sufficient security budget through tail-end emissions.

### [Manipulation Resistance Analysis](https://ecip1120.dev/manipulation-resistance)

Simulate attack vectors including spam transactions, empty block mining, and off-chain fee agreements. Verify the chosen parameters adequately disincentivize these behaviors.

### [Elasticity Multiplier Selection](https://ecip1120.dev/elasticity)

Determine the optimal `ELASTICITY_MULTIPLIER` for ETC. Higher values (4x, 16x, 32x) enable larger maximum transaction sizes, achieving feature parity with Ethereum. This requires benchmarking client performance and network propagation to identify the highest safe value.

### [Distribution Curve Design](https://ecip1120.dev/distribution-logic)

Determine the optimal `BACKWARD_FEES_BLOCK_COUNT` and whether to use a uniform or decay curve. Analyze historical ETC block patterns to understand typical periods without transactions, and model how different curves affect miner incentives.

### [Client Benchmarking](https://ecip1120.dev/benchmarking)

Test Core-Geth and Besu performance at various elasticity multipliers and gas limits. Measure block processing time, propagation latency, and uncle rates to establish safe operating parameters.

### [Test Vectors](https://ecip1120.dev/test-vectors)

Reference test vectors for Basefee adjustment, fee distribution calculations, and edge cases (empty blocks, maximum utilization) will be published to facilitate client implementation testing.

## Implementation Plan

ECIP-1120 is designed for deployment in a single hard fork rather than incremental activations. A unified approach reduces complexity by avoiding intermediate states, cross-fork compatibility concerns, and multiple coordination efforts across clients, miners, and ecosystem participants. It also ensures completeness, as all components (Type 2 transactions, Basefee calculation, fee distribution, BASEFEE opcode) activate together, preventing partial implementations that could create unexpected behavior or security gaps.

This section outlines the path from WIP to mainnet activation.

### Research & Specification Finalization

_Estimated duration: 2-4 months_

Complete the [Research Plan](#research-plan) items above. Finalize all parameters. Publish test vectors and progress this ECIP through Draft → Last Call → Accepted status.

### Client Implementation

_Estimated duration: 2-4 months_

Implement the finalized specification in ETC clients (Core-Geth, Besu, Fukuii). Complete code review, testing, and auditing.

### Testnet Deployment

_Estimated duration: 2 months_

Activate on Mordor testnet. Monitor for issues, validate test vectors, and confirm cross-client compatibility.

### Consensus Signalling

_Estimated duration: 0-2 months_

If necessary, gather explicit support via miner signalling (block header extra data), node operator statements, and confirmation of upgrade readiness from exchanges and wallets.

### Mainnet Hard Fork

Announce the mainnet activation block height with adequate lead time. Activation proceeds at the designated block, preserving network unity and avoiding a chain split.

## Conclusion

This ECIP proposes a minimal implementation of EIP-1559 for Ethereum Classic, adapting the Basefee market mechanism while distributing fees to miners rather than burning them. The backward-looking fee distribution preserves ETC's fixed monetary policy under ECIP-1017, maintains chain security as block subsidies decline, and resists manipulation through ℓ-smoothing. Pending completion of the outlined research, this proposal provides a path toward EIP-1559 compatibility while respecting Ethereum Classic's unique requirements.

## References

- [EIP-1559: Fee market change for ETH 1.0 chain](https://eips.ethereum.org/EIPS/eip-1559)
- [EIP-2718: Typed Transaction Envelope](https://eips.ethereum.org/EIPS/eip-2718)
- [EIP-2930: Optional access lists](https://eips.ethereum.org/EIPS/eip-2930)
- [EIP-3198: BASEFEE opcode](https://eips.ethereum.org/EIPS/eip-3198)
- [ECIP-1017: Monetary Policy and Final Modification to the Ethereum Classic Emission Schedule](https://ecips.ethereumclassic.org/ECIPs/ecip-1017)
- [Roughgarden, T. Transaction Fee Mechanism Design for the Ethereum Blockchain](https://timroughgarden.org/papers/eip1559.pdf)

## License

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
