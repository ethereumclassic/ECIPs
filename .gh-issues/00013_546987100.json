{
    "url": "https://api.github.com/repos/ethereumclassic/ECIPs/issues/comments/546987100",
    "html_url": "https://github.com/ethereumclassic/ECIPs/issues/13#issuecomment-546987100",
    "issue_url": "https://api.github.com/repos/ethereumclassic/ECIPs/issues/13",
    "id": 546987100,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU0Njk4NzEwMA==",
    "user": {
      "login": "AndreaLanfranchi",
      "id": 15280851,
      "node_id": "MDQ6VXNlcjE1MjgwODUx",
      "avatar_url": "https://avatars0.githubusercontent.com/u/15280851?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AndreaLanfranchi",
      "html_url": "https://github.com/AndreaLanfranchi",
      "followers_url": "https://api.github.com/users/AndreaLanfranchi/followers",
      "following_url": "https://api.github.com/users/AndreaLanfranchi/following{/other_user}",
      "gists_url": "https://api.github.com/users/AndreaLanfranchi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AndreaLanfranchi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AndreaLanfranchi/subscriptions",
      "organizations_url": "https://api.github.com/users/AndreaLanfranchi/orgs",
      "repos_url": "https://api.github.com/users/AndreaLanfranchi/repos",
      "events_url": "https://api.github.com/users/AndreaLanfranchi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AndreaLanfranchi/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-10-28T15:00:07Z",
    "updated_at": "2019-10-28T15:07:11Z",
    "author_association": "NONE",
    "body": "> In the current Ethash system, the mixHash is a 256-bit string constructed based on the state of the blockchain. This is concatenated with the nonceHeader, 64-bit, and the entirety (320-bits) of it is hashed to verify proof of work.\r\n\r\nNot completely accurate :\r\n\r\n1. Miners receive the header hash which is a hash of **candidate** block state (not the state of the chain)\r\n2. Header hash is combined with nonce to fill the initial state of keccak function\r\n3. Initial state goes through a first round of Keccak\r\n4. Generated (from point 3) mix is FNV'ed against 64 pseudo random accesses to DAG\r\n5. Output is then copied into state and processed through an additional round of Keccak\r\n7. Resulting dwords[0-3] are checked against target\r\n\r\n> For this proposal we recommend miners being able to fill the mixHash field with whatever data they desire. This will allow for a total of 320-bits for miners to use for both submitting proof of work, but also to signal mining pools and voting on certain ECIP proposals.\r\n\r\nUnless I miss something how the proof of work is supposed to be verified ?\r\nThis should imply sending the work provider (the node or pool) full initial mix (as composed by miner) **plus** both the final target and the final state of keccak: by consequence network traffic among work-consumers (miners) and work-providers (node/pools) is more than quadrupled with non trivial problems especially on pool's sides.",
    "reactions": {
      "url": "https://api.github.com/repos/ethereumclassic/ECIPs/issues/comments/546987100/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 1
    }
  }